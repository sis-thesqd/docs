---
title: "AA26"
author: "Jacob Vendramin"
date: "2025-12-16"
last_updated: "2025-12-16"
tags: ["auto-scheduler"]
version: "1.0.0"
---

# ðŸ’¨ AA26

## ðŸŽ¯ Beginner's Guide: Quick Reference

### What Controls What

**Config Controls** (sis_config table)
- **Task eligibility**: `task_processing_filters` determines if a task is ready for auto-assignment
- **Designer filtering**: `min_preference_score` filters designers by account preference
- **Preference behavior**: `skip_preference_score_after` controls when preferences are ignored (>14 days)
- **Final selection**: `Decision Script Configuration` controls how the final designer is chosen
- **Output format**: `Master Output Config` controls what data is returned

**Where to Look for Different Things**

| What You Need | Where to Find It | File/Location |
|--------------|------------------|---------------|
| Modify task validation rules | `task_processing_filters` config | sis_config table |
| Change preference score threshold | `min_preference_score` config | sis_config table |
| Adjust selection logic | `Decision Script Configuration` config | sis_config table |
| Update business logic | Core functions | f/aa26_v2/core.py |
| Change script parameters | Script entry points | f/aa26_v2/{script}.py |
| Modify RPC queries | Supabase functions | as_get_task_processing_data, as_get_assignees_data |
| View execution logs | Database table | as_log table |
| Check designer availability | Database table | as_designer_availabilities table |

### Quick Troubleshooting

**Task not processing?**
1. Check `task_processing_filters` in sis_config
2. Verify task passes all three filters: not a subtask, no designer assigned, status not blocked
3. Check as_log table for error messages

**Wrong designer selected?**
1. Review `Decision Script Configuration` settings
2. Check if `high_usage` flag is affecting priority rules
3. Verify preference scores in account data

**Preference scores not working?**
1. Check if task is >14 days out (controlled by `skip_preference_score_after`)
2. Verify `min_preference_score` threshold
3. Confirm preference data exists in as_get_task_assignment_data

---

## ðŸ“š Complete Technical Guide

### Architecture Overview

The AA26 workflow consists of 6 core scripts that execute in a specific order:

```javascript
Master Script (orchestrator)
â”œâ”€â”€ 1. Config Script (fetch all configs)
â”œâ”€â”€ 2. Task Script (validate & fetch task data)
â”œâ”€â”€ 3. Account Script (fetch designer preferences)
â”œâ”€â”€ 4. Assignees Script (calculate availability)
â””â”€â”€ 5. Decision Script (select final designer)
```

**Execution Flow:**
- **Parallel Phase**: Config, Task, and Account run simultaneously
- **Sequential Phase**: Assignees waits for Task + Account, then Decision waits for all previous

---

## ðŸ”§ Script Reference

### 1. Config Script

**Path**: `f/aa26_v2/config.py`

**Purpose**: Fetches all aa26 configuration from sis_config table

**Entry Point**:
```python
def main(task_id: str) -> dict
```

**Returns**:
```json
{
  "task_id": "86dyjhcya",
  "configs": [
    {
      "id": "uuid",
      "workflows": ["f/aa26/master"],
      "metadata": {"key": "value"}
    }
  ]
}
```

**Key Function**: `fetch_all_aa26_configs()` in core.py:50-66

---

### 2. Task Script

**Path**: `f/aa26_v2/task.py`

**Purpose**: Validates task eligibility and fetches task processing data

**Entry Point**:
```python
def main(task_id: str = None, config_data: dict = None,
         account: str = None, tag: str = None) -> dict
```

**Accepts Two Modes**:
1. **Task ID Mode**: Provide `task_id` to fetch specific task
2. **Account/Tag Mode**: Provide `account` + `tag` to query by account and tag name

**Key Config Used**: `task_processing_filters`

**Validation Filters** (applied in core.py:185-202):
1. **must_not_be_subtask**: Checks if `task.parent` is null in ClickUp API data
2. **auto_assign_status_blocked_values**: Filters out tasks with status in ["blocked", "complete", "queued"]
3. **designer_department_must_be_empty**: Ensures no assignee has "Design" in department

**Returns**:
```json
{
  "task_id": "86dyjhcya",
  "task_name": "Design church bulletin",
  "estimate": 120,
  "max_days_out": 20,
  "min_days_out": 2,
  "department": "Design Squad",
  "tag": "Bulletin",
  "project_type": "Print",
  "ready_to_process": true,
  "is_subtask": false
}
```

**Database Upsert**: Writes to `as_log` table (core.py:235-261)

**RPC Called**: `as_get_task_processing_data` or `as_tag_time_analysis`

---

### 3. Account Script

**Path**: `f/aa26_v2/account.py`

**Purpose**: Fetches account data including designer preferences

**Entry Point**:
```python
def main(task_id: str, config_data: dict) -> dict
```

**Key Config Used**: `min_preference_score`

**Preference Score Filtering** (account.py:31-36):
- Filters designers where `preference_score >= min_preference_score`
- Scores: 0 (not preferred), 1 (default), 2 (preferred), 3 (recommended), 4 (both)

**Returns**:
```json
{
  "task_id": "86dyjhcya",
  "account": "1234",
  "high_usage": false,
  "active_tasks": 5,
  "cap": 10,
  "room": 5,
  "designers": [
    {
      "clickup_id": "12345",
      "preference_score": 3,
      "preference_score_text": "recommended"
    }
  ]
}
```

**Database Upsert**: Writes to `as_log` table (core.py:293-318)

**RPC Called**: `as_get_task_assignment_data`

---

### 4. Assignees Script

**Path**: `f/aa26_v2/assignees.py`

**Purpose**: Calculates designer availability for all eligible dates

**Entry Point**:
```python
def main(task_id: str = None, config_data: dict = None,
         task_data: dict = None, account_data: dict = None,
         account: str = None, tag: str = None,
         only_output_available: bool = False) -> dict
```

**Accepts Two Modes**:
1. **Task ID Mode**: Uses task_id to fetch data
2. **Account/Tag Mode**: Uses account + tag with optional estimate/min_days/max_days overrides

**Key Configs Used**:
- `skip_preference_score_after` (preference_score_skip: 14)
- `estimate_buffer` (1.02 multiplier)
- `assignees_config` (RPC parameters)

**Processing Steps** (core.py:366-454):
1. Fetch designer availability from RPC
2. Add preference scores from account data
3. Apply preference_score_skip rule (reset to 1 if days_out > 14)
4. Calculate total_available (available_priority + available_standard)
5. Optionally filter to only available designers

**Returns**:
```json
{
  "task_id": "86dyjhcya",
  "designers": [
    {
      "designer": "John Doe",
      "email": "john@example.com",
      "days_out": 3,
      "available_priority": 120,
      "available_standard": 240,
      "total_available": 360,
      "preference_score": 3
    }
  ]
}
```

**Database Upsert**: Writes to `as_designer_availabilities` table (core.py:456-499)

**RPC Called**: `as_get_assignees_data`

---

### 5. Decision Script

**Path**: `f/aa26_v2/decision.py`

**Purpose**: Selects the final designer based on priority rules

**Entry Point**:
```python
def main(task_id: str, config_data: dict, task_data: dict,
         account_data: dict, assignees_data: dict) -> dict
```

**Key Config Used**: `Decision Script Configuration`

**Decision Logic** (core.py:566-656):

**Step 1: Apply Filters**
- Exclude designers with preference_score < 1 (not_preferred/not_recommended)
- Exclude designers with exclude.value = true
- Exclude designers where total_available <= task estimate

**Step 2: Sort by Priority**
1. days_out (ascending - earliest first)
2. prev_des (descending - previous designer prioritized)
3. preference_score (descending - higher preference first)
4. max_possible capacity (descending - more capacity first)

**Step 3: Limit Results**
- Limit to first `max_days_out_limit` unique days (default: 5)
- Ensure at least `min_results` designers (default: 10)
- Apply `preference_days_out_threshold`: reset preference_score to 1 for days_out >= 14

**Step 4: Select Final Designer**
1. If NOT high_usage: Select first designer with prev_des = 1
2. If NOT high_usage: Select first designer with preference_score >= 2
3. Fallback: Select first designer in sorted list

**Returns**:
```json
{
  "task_id": "86dyjhcya",
  "selected_designer": {
    "designer": "John Doe",
    "email": "john@example.com",
    "days_out": 3,
    "due_date": "2025-12-18"
  }
}
```

**Database Upsert**: Writes to `as_log` table with final selection (core.py:711-743)

---

### 6. Master Script

**Path**: `f/aa26_v2/master.py`

**Purpose**: Orchestrates all scripts and handles execution flow

**Entry Point**:
```python
def main(task_id: str = None, make_selection: bool = True,
         account: str = None, tag: str = None,
         only_output_available: bool = False) -> dict
```

**Parameters**:
- `task_id`: ClickUp task ID (optional if account/tag provided)
- `make_selection`: Run decision script (default: true)
- `account`: Account number for account/tag mode
- `tag`: Tag name for account/tag mode
- `only_output_available`: Filter to only available designers

**Execution Phases**:

**Phase 1: Parallel Fetch** (master.py:78-113)
```python
config_raw, task_raw, account_raw, clickup_raw = await asyncio.gather(
    fetch_all_aa26_configs(),
    fetch_task_data(task_id) or fetch_tag_time_analysis(account, tag),
    fetch_task_assignment_data(task_id),
    fetch_clickup_task(session, task_id)
)
```

**Phase 2: Process Task & Account** (master.py:118-227)
- Process task data with filters
- Process account data with preference filtering
- Upsert to as_log

**Phase 3: Assignees** (master.py:229-301)
- Fetch designer availability
- Add preference scores
- Apply preference_score_skip
- Calculate total_available
- Upsert to as_designer_availabilities

**Phase 4: Decision** (master.py:303-376, optional)
- Apply decision filters
- Sort and limit designers
- Select final designer
- Generate decision log
- Upsert to as_log

**Config Filtering** (master.py:28-45):
```python
def filter_config_for_script(config_data: dict, script_name: str) -> dict:
    # Merges metadata from all configs where script_name is in workflows array
```

**Returns**:
```json
{
  "success": true,
  "task_id": "86dyjhcya",
  "config": {"configs": [...]},
  "task": {...},
  "account": {...},
  "assignees": {...},
  "decision": {...},
  "execution_time_ms": 1250
}
```

**Account/Tag Mode**: Returns only assignees and decision (skips task/account/config)

**Key Config Used**: `Master Output Config` controls if config object is included

---

## âš™ï¸ Configuration Reference (sis_config)

### aa26_global_constants

**Workflows**: f/aa26/master, f/aa26/task, f/aa26/assignees

**Metadata**:
```json
{
  "blocked_domain": "external.com",
  "request_timeout": 30,
  "valid_space_ids": ["12345", "67890"],
  "default_max_days_out": 20,
  "default_min_days_out": 2
}
```

**Usage**:
- `request_timeout`: HTTP client timeout for ClickUp API (task.py:46)
- `blocked_domain`: Prevents external assignees from blocking auto-assignment
- `valid_space_ids`: Eligible ClickUp spaces for processing
- `default_max_days_out` / `default_min_days_out`: Date range window defaults

---

### min_preference_score

**Workflows**: f/aa26/account

**Metadata**:
```json
{
  "min_preference_score": 2
}
```

**Usage**: Filters designers in account.py:31-36 and master.py:204-209
- Only keeps designers with preference_score >= 2
- Removes default (1) and not_preferred (0) designers

---

### task_processing_filters

**Workflows**: f/aa26/task

**Metadata**:
```json
{
  "ready_to_process_filters": {
    "must_not_be_subtask": true,
    "assignee_must_not_contain": "Design",
    "auto_assign_status_blocked_values": ["blocked", "complete", "queued"]
  }
}
```

**Usage**: Applied in core.py:185-202
- Validates task eligibility for auto-assignment
- Task must pass ALL filters to be ready_to_process

---

### skip_preference_score_after

**Workflows**: f/aa26/assignees

**Metadata**:
```json
{
  "preference_score_skip": 14
}
```

**Usage**: Applied in core.py:392-415
- For designers with days_out > 14, resets preference_score to 1
- Sets preference_score_text to "days_out_override"
- Ensures urgency takes precedence over preferences for distant dates

---

### assignees_config

**Workflows**: f/aa26/assignees

**Metadata**:
```json
{
  "result_limit": 100,
  "default_max_days": 20,
  "default_min_days": 2,
  "default_department": "Design Squad",
  "priority_buffer_ratio": 0.3,
  "check_subtask_via_clickup": true
}
```

**Usage**: Used by as_get_assignees_data RPC function
- Controls RPC query parameters and filtering logic

---

### estimate_buffer

**Workflows**: f/aa26/assignees

**Metadata**:
```json
{
  "estimate_buffer": 1.02
}
```

**Usage**: Used by as_get_assignees_data RPC function
- Multiplies estimate by 1.02 before availability comparison
- Provides 2% buffer for estimation variance

---

### Decision Script Configuration

**Workflows**: f/aa26/decision

**Metadata**:
```json
{
  "high_usage": false,
  "min_results": 10,
  "max_days_out_limit": 5,
  "availability_output": "single",
  "preference_days_out_threshold": 14
}
```

**Usage**:
- `high_usage`: Skips prev_des and preference_score priority rules (core.py:644-656)
- `min_results`: Minimum designers to return (core.py:611-628)
- `max_days_out_limit`: Limit to first X unique days (core.py:609)
- `availability_output`: "single" selects one, "all" returns all (decision.py:35, master.py:319)
- `preference_days_out_threshold`: Reset scores for days_out >= 14 (core.py:611-618)

---

### Master Output Config

**Workflows**: f/aa26/master

**Metadata**:
```json
{
  "output_config_data": false
}
```

**Usage**: Controls config inclusion in master.py:390-424
- When false, excludes config object from response (reduces payload size)
- When true, includes full config array

---

### Timeoff Patterns Configuration

**Workflows**: f/aa26/assignees

**Metadata**:
```json
{
  "timeoff_patterns": {
    "full_day": {
      "description": "Full day off - sets leave to max capacity and availability to 0",
      "amount_values": ["all_of_the_day"],
      "workdays_off_threshold": 1
    },
    "half_day": {
      "description": "Half day off - sets leave to half capacity and cuts availability in half",
      "amount_values": ["half_of_the_day"],
      "workdays_off_equals": 1
    },
    "hours_based": {
      "description": "Hours-based timeoff - parses hours from amount field and reduces availability accordingly",
      "amount_pattern": "%hours%",
      "workdays_off_equals": 1
    }
  }
}
```

**Usage**: Used by as_get_assignees_data RPC function
- Parses time-off records from timeoff data source
- Calculates leave and reduces availability accordingly

---

## ðŸ—„ï¸ Database Tables

### as_log

**Purpose**: Tracks execution history and final decisions for each task

**Key Columns**:
- `task_id` (primary key)
- `task_name`, `estimate`, `department`, `tag`
- `account`, `high_usage`, `active_tasks`
- `selected_designer`, `assignee_id`, `selected_due_date`
- `narrative` (decision log message)
- `total_options_count`
- `status` (in_progress â†’ completed)

**Populated By**:
- Task script: task metadata
- Account script: account metadata
- Decision script: final selection and narrative

---

### as_designer_availabilities

**Purpose**: Stores designer availability snapshots for each task execution

**Key Columns**:
- `task_id`, `clickup_id`, `date` (composite key)
- `designer`, `email`, `department`
- `days_out`
- `available_priority`, `available_standard`
- `max_possible`, `scheduled`, `blocked`, `leave`
- `exclude_reason`, `exclude_value`
- `preference_score`, `preference_score_text`

**Populated By**: Assignees script (core.py:456-499)

---

## ðŸ”Œ Supabase RPC Functions

### as_get_task_processing_data

**Parameters**: `input_task_id`

**Returns**: Task metadata including estimate, tags, dependencies, assignees, status

**Called By**: Task script (core.py:73-87)

---

### as_tag_time_analysis

**Parameters**: `input_account_number`, `input_tag_name`

**Returns**: Historical time data for account/tag combination

**Called By**: Task script in account/tag mode (core.py:90-112)

---

### as_get_task_assignment_data

**Parameters**: `input_task_id`

**Returns**: Account data with designer preferences and account metadata

**Called By**: Account script (core.py:268-282)

---

### as_get_assignees_data

**Parameters**:
- `input_task_id` (optional)
- `input_account` (optional)
- `input_tag` (optional)
- `input_estimate` (optional)
- `input_min_days` (optional)
- `input_max_days` (optional)

**Returns**: Designer availability data for date range

**Called By**: Assignees script (core.py:325-363)

**Config Integration**: Uses `assignees_config`, `estimate_buffer`, `Timeoff Patterns Configuration`

---

## ðŸš€ API Usage Examples

### Execute Full Workflow
```bash
curl -X POST https://api.windmill.dev/w/sis/jobs/run/f/aa26_v2/master \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"task_id": "86dyjhcya"}'
```

### Execute with Account/Tag Mode
```bash
curl -X POST https://api.windmill.dev/w/sis/jobs/run/f/aa26_v2/master \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"account": "1234", "tag": "Bulletin"}'
```

### Get Availability Only (No Selection)
```bash
curl -X POST https://api.windmill.dev/w/sis/jobs/run/f/aa26_v2/master \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"task_id": "86dyjhcya", "make_selection": false}'
```

---

## ðŸŽ“ Common Scenarios

### Scenario 1: Modify Task Eligibility Rules

**Goal**: Add a new filter to exclude tasks with specific tags

**Steps**:
1. Update `task_processing_filters` config in sis_config table
2. Add new filter function in core.py (around line 152-182)
3. Call new filter in `apply_task_filters()` function
4. Test with sample tasks

---

### Scenario 2: Change Preference Score Threshold

**Goal**: Only consider highly preferred designers (score >= 3)

**Steps**:
1. Update `min_preference_score` config:
```sql
UPDATE sis_config
SET metadata = jsonb_set(metadata, '{min_preference_score}', '3')
WHERE name = 'min_preference_score';
```
2. No code changes needed - config is read dynamically

---

### Scenario 3: Adjust Days-Out Threshold for Preference Reset

**Goal**: Reset preferences at 10 days instead of 14

**Steps**:
1. Update `skip_preference_score_after` config:
```sql
UPDATE sis_config
SET metadata = jsonb_set(metadata, '{preference_score_skip}', '10')
WHERE name = 'skip_preference_score_after';
```
2. No code changes needed

---

### Scenario 4: Debug Why a Task Wasn't Processed

**Steps**:
1. Check as_log table for task_id
2. Look for `ready_to_process: false`
3. Check task filters in core.py:185-202
4. Verify task data meets all criteria:
   - Not a subtask
   - Status not in blocked values
   - No designer already assigned

---

### Scenario 5: Understand Why a Specific Designer Was Selected

**Steps**:
1. Check as_log.narrative for decision log message
2. Review decision priority rules in core.py:633-656
3. Check if prev_des = 1 or preference_score >= 2
4. Verify high_usage setting in Decision Script Configuration

---

## ðŸ“Š Performance Optimization

### Parallel Execution

Master script runs config, task, and account fetches in parallel (master.py:78-113):
```python
await asyncio.gather(
    fetch_all_aa26_configs(),
    fetch_task_data(task_id),
    fetch_task_assignment_data(task_id),
    fetch_clickup_task(session, task_id)
)
```

**Benefit**: Reduces execution time by ~40%

---

### Connection Pooling

Core.py uses persistent PostgREST clients (core.py:29-43):
```python
POSTGREST_READ_CLIENT = AsyncPostgrestClient(...)
POSTGREST_WRITE_CLIENT = AsyncPostgrestClient(...)
```

**Benefit**: Reuses connections across requests

---

### Batch Upserts

Designer availabilities are upserted in batches of 100 (core.py:489-494):
```python
batch_size = 100
for i in range(0, len(records), batch_size):
    batch = records[i:i + batch_size]
    await POSTGREST_WRITE_CLIENT.from_("as_designer_availabilities").upsert(batch)
```

**Benefit**: Reduces database round trips
